main.c :
#include <gint/display.h>
#include <gint/keyboard.h>
#include <stdlib.h>

#include "moteur.h"

//====== Raycaster (faut trouver un nom) =====
// 
// Game design : Fcalva
// Programmation : Fcalva
// Art : Redoki303, Fcalva
// 
// 
// 
// 
// 
//Problèmes :
//-L'affichage est très mauvais, a revoir
//-Le mouvement de la caméra ne marche pas
//
// Je garde le bout en dessous pour des raisons
//A rajouter d'ici le 27 :
//-Que ça marche (logique)
// -collisions
// -Sol
// -Gestion de plusieurs maps
// -Intéraction (Portes/boutons)
// -Textures
// -Sprites
// -PNJs ( a voir selon le thème)
// -Extérieur/intérieur (très probablement mais a voir selon le thème)
//La suite dépend surtout de ce qui aura été fait et du thème
//Avec le thème, maintenant il faudrait :
//-collisions
// -sol
// -Des bouts de map reliés entre eux
// -Sprites (ennemis + ambiance dans un second temps)
// -map générées aléatoirement
// -textures
// -Gameplay
// -PNJs
// -Sans de undertale (me demandez pas pourquoi, c'est un mec sur discord qui a proposé)
// 
// 
//
int player_x;
int player_y;
//int player_z; pour un futur fort fort lointain, pas pour le CPC 2023
int player_dir;

int cos_table[360];
int sin_table[360];
int tan_table[360];
int acos_table[360];
int asin_table[360];
int atan_table[360];
int tab_mur_x[180];
int tab_mur_y[180];
int distors_table[60];

int main(void){
	dclear(C_WHITE);
	compute_table();

	float angle_60;
	angle_60 = FOV / viewport_h;
	char angle_30;
	char angle_15;
	char angle_90;
	char angle_180;
	char angle_270;
	char angle_360;
	char angle_5;
	char angle_10;
	char angle_45;
	angle_30 = floor(angle_60 * 0.5);
	angle_15 = floor(angle_60 * 0.25);
	angle_90 = floor(angle_60 * 1.5);
	angle_180 = floor(angle_60 * 3);
	angle_270 = floor(angle_60 * 4.5);
	angle_360 = floor(angle_60 * 6);
	angle_5 = floor(angle_60 / 12);
	angle_10 = floor(angle_60 / 6);
	angle_45 = floor(angle_60 * 0.75);
	
	int temp;
	temp = 0;

	///generate_horizon_gradient();
	load_map();

	dtext(1, 1, C_BLACK, "projet CPC 23 : Raycaster");

	dupdate();
	
	getkey();
	while (true) {
		dclear(C_BLACK);
		//draw_background();
		draw_walls();

		/**/dtext(1, temp, C_WHITE, "coucou"); //passé
		temp++;
		if (temp >= 240) {
			temp = 0;
		}
		dupdate();
		/*if (keydown(KEY_UP)) {
			//flemme d'implémanter le mouvement, verrai quand le rendu marche
		}*/
		if (keydown(KEY_LEFT)) {
			player_dir -= 5;
		}
		if (keydown(KEY_RIGHT)) {
			player_dir += 5;
		}
		if (keydown(KEY_MENU)) {
			return 1;
		}
	}
}
moteur.h :
#ifndef moteur.h
//#define moteur.h

#define pi 3.1415

//param. graphiques
#define screen_w 396
#define screen_h 224
#define viewport_w 396
#define viewport_h 224
//#define fps_cap 30
#define FOV 60
#define max_dist 640 // peut-être un peu élevé
#define player_pj_pl_dist 145 //distance du joueur au plan de projection

#define couleur_ciel 0x0ADF

//param. de jeu
#define tile_size 32
#define wall_size 32
#define player_height 16
#define player_speed 8

float deg_to_rad(float angle_deg);

void compute_table();
int load_map();
void draw_background();
void draw_walls();
//temp
/*int generate_horizon_gradient(void); //bout collectivisé de Lephe
#define RGB24(hex) \
    (((hex & 0xf80000) >> 8) | \
     ((hex & 0x00fc00) >> 5) | \
     ((hex & 0x0000f8) >> 3))
*/
#define map_w 13
#define map_h 13
#define startpos_x 0
#define startpos_y 0
#define startdir 0 //en degrés
#define wall_color 0xAAAA

#endif /* moteur.h */
moteur.c :
#include <gint/display.h>
#include <gint/keyboard.h>
#include "moteur.h"
//#include "sprites.h"
#include "map_test.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

float deg_to_rad(float angle_deg) {
	return((angle_deg * pi) / 180);
}

void compute_table() {
	extern int cos_table[];
	extern int sin_table[];
	extern int tan_table[];
	extern int acos_table[];
	extern int asin_table[];
	extern int atan_table[];
	extern int tab_mur_x[];
	extern int tab_mur_y[];
	extern int distors_table[];
	int i = 0;
	float rad_i = 0;
	while (i != 360) {
		rad_i = deg_to_rad(i);
		cos_table[i] = floor(64*cos(rad_i));
		sin_table[i] = floor(64*sin(rad_i));
		tan_table[i] = floor(64*tan(rad_i));
		acos_table[i] = floor(64*(acos(rad_i)));
		asin_table[i] = floor(64*(asin(rad_i)));
		atan_table[i] = floor(64*(atan(rad_i)));
		if (i >= 90 && i < 270) {
			tab_mur_x[i] = floor(tile_size / tan(i)*64);
			if (tab_mur_x[i] > 0) {
				tab_mur_x[i] = -tab_mur_x[i];
			}
		}
		else {
			tab_mur_x[i] = floor(tile_size / tan(i) * 64);
			if (tab_mur_x[i] < 0) {
				tab_mur_x[i] = -tab_mur_x[i];
			}
		}
		if (i >= 0 && i < 180) {
			tab_mur_y[i] = floor(tile_size / tan(i) * 64);
			if (tab_mur_y[i] < 0) {
				tab_mur_y[i] = -tab_mur_y[i];
			}
		}
		else {
			tab_mur_y[i] = floor(tile_size / tan(i) * 64);
			if (tab_mur_y[i] > 0) {
				tab_mur_y[i] = -tab_mur_y[i];
			}
		}
		i++;
	}
	for (i = -30; i <= 30; i++) {
		distors_table[i + 30] = floor(64*1 / cos(deg_to_rad(i)));
	}
}
int load_map() {
	extern int player_x;
	extern int player_y;
	extern int player_dir;
	player_x = startpos_x;
	player_y = startpos_y;
	player_dir = startdir;
	//faudrait d'autres trucs quand y aura plusieurs maps
	//*tout changer x|
	return 1;
}
void draw_background() {
	//très simple pour le moment, je vais sans doute améliorer
	//ajout 28 : pas de dehors donc pas d'arrière plan
	drect(1, 1, viewport_w, viewport_h*0.5 , couleur_ciel);
}
void draw_walls() {
	int vertical_grid;
	int horizontal_grid;
	int dist_to_n_v_grid; //distance to next vertical grid
	int dist_to_n_h_grid; //a changer si max_dist (distance de rendu) > 255
	int x_intersect;
	int y_intersect;
	int dist_to_n_x_intersect;
	int dist_to_n_y_intersect;
	int x_raypos;
	int y_raypos;
	int dist_to_v_hit;
	int dist_to_h_hit;
	int castarc = 0;
	int castcolumn;
	int xtemp;
	int ytemp;
	int mapindex;
	float wall_dist;
	float scale_factor;
	int wall_haut;
	int wall_bas;
	int couleur;
	int proj_wall_h;
	char angle_30;//il y en a peut être des inutilisés, a voir
	char angle_15;
	char angle_90;
	char angle_180;
	char angle_270;
	char angle_360;
	char angle_5;
	char angle_10;
	char angle_45;
	extern int cos_table[];
	extern int sin_table[];
	extern int tan_table[];
	extern int acos_table[];
	extern int asin_table[];
	extern int atan_table[];
	extern int tab_mur_x[];
	extern int tab_mur_y[];
	extern int distors_table[];
	extern int player_x;
	extern int player_y;
	extern int player_dir;
	extern char map_test[map_w][map_h];
	castcolumn = 1;
	castarc = player_dir - 30;
	if (castarc > 360) {
		castarc -= 360;
	}
	while (castcolumn < viewport_w) {
		if (castarc > 0 && castarc < angle_180) {
			horizontal_grid = floor(player_y / tile_size) * tile_size + tile_size;
			dist_to_n_h_grid = tile_size;
			xtemp = floor((atan_table[castarc] * (horizontal_grid - player_y)) * 0.015625);
			x_intersect = xtemp + (player_x);
		}
		else {
			horizontal_grid = (floor(player_y / tile_size) * tile_size);
			dist_to_n_h_grid = -tile_size;
			xtemp = floor(atan_table[castarc] * (horizontal_grid - player_y) * 0.015625);
			x_intersect = xtemp + player_x;
			horizontal_grid--;
		}
		if (castarc == 0 || castarc == angle_180) {
			dist_to_h_hit = max_dist;
		}
		else {
			dist_to_n_x_intersect = floor(tab_mur_x[castarc] * 0.015625);
			while (true) {
				x_raypos = floor(x_intersect / tile_size);
				y_raypos = floor(horizontal_grid / tile_size);
				mapindex = floor(y_raypos * map_w + x_raypos);
				if (x_raypos >= map_w || y_raypos >= map_h || x_raypos > max_dist || y_raypos > max_dist) {
					dist_to_h_hit = max_dist;
					break;
				}
				else if (map_test[x_raypos][y_raypos] != 0) { // a changer pour avoir plusieurs types de murs
					dist_to_h_hit = floor((x_intersect - player_x) * acos_table[castarc] * 0.015625);
					break;
				}
				else {
					x_intersect += dist_to_n_x_intersect;
					horizontal_grid += dist_to_n_h_grid;
				}
			}
		}
		if (castarc < angle_90 || castarc > angle_270) {
			vertical_grid = tile_size + floor(player_x / tile_size) * tile_size;
			dist_to_n_v_grid = tile_size;
			ytemp = floor(tan_table[castarc] * (vertical_grid - player_x) * 0.015625);
		}
		else {
			vertical_grid = floor(player_x / tile_size) * tile_size;
			dist_to_n_v_grid = -tile_size;
			ytemp = floor(tan_table[castarc] * (vertical_grid - player_x) * 0.015625);
			y_intersect = ytemp + player_y;
			vertical_grid--;
		}
		if (castarc == angle_90 || castarc == angle_270) {
			dist_to_v_hit = max_dist;
		}
		else {
			dist_to_n_y_intersect = floor(tab_mur_y[castarc] * 0.015625);
			while (true) {
				x_raypos = floor(vertical_grid / tile_size);
				y_raypos = floor(y_intersect / tile_size);
				mapindex = floor(y_raypos * map_w + x_raypos);
				if (x_raypos >= map_w || y_raypos >= map_h || x_raypos > max_dist || y_raypos > max_dist) {
					dist_to_h_hit = max_dist;
					break;
				}
				else if (map_test[x_raypos][y_raypos] != 0) {
					dist_to_v_hit = floor((y_intersect - player_y) * asin_table[castarc] * 0.015625);
					break;
				}
				else {
					y_intersect += dist_to_n_y_intersect;
					vertical_grid += dist_to_n_v_grid;
				}
			}
		}
		if (dist_to_h_hit < dist_to_v_hit) {
			wall_dist = dist_to_h_hit;
		}
		else {
			wall_dist = dist_to_v_hit;
		}
		wall_dist /= distors_table[castcolumn] * 0.015625;
		proj_wall_h = floor(wall_size * player_pj_pl_dist / wall_dist);
		wall_bas = viewport_h - (viewport_h * 0.5 + floor(proj_wall_h * 0.5));
		wall_haut = viewport_h - (viewport_h * 0.5 - floor(proj_wall_h * 0.5));
		wall_bas = wall_haut - wall_bas + 1;
		if (wall_haut < 0) {
			wall_haut = 0;
		}
		if (wall_bas >= viewport_h) {
			wall_bas = viewport_h - 1;
		}
		if (wall_dist < max_dist) {
			couleur = floor(255 - (wall_dist / max_dist) * 255);
			if (couleur <= 20) {
				couleur = 20;
			}
			drect(castcolumn, wall_haut, castcolumn + 1, wall_bas, wall_color);
		}
		else {
			drect(castcolumn, wall_haut, castcolumn + 1, wall_bas, 0x0000);
		}
		castarc += floor(viewport_w * 1 / FOV);
		castcolumn += 2;
		if (castarc > 360) {
			castarc -= 360;
		}
	}
}
map_test.h :
#ifndef map_test.h
//#define map_test.h

#define map_w 13
#define map_h 13
#define startpos_x 0
#define startpos_y 0
#define startdir 0 //en degrés

#endif /* map_test.h */
map_test.c :
//#include ici quand qu'il y aura besoin
#include "map_test.h"
char map_test[map_w][map_h] = {
	{1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,1,0,0,0,1,1,1,0,1},
	{1,0,0,0,0,0,0,0,0,0,1,0,1},
	{1,0,0,1,0,0,0,0,0,0,1,0,1},
	{1,0,0,0,0,0,0,0,0,0,1,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,1,0,1,0,1,0,0,0,0,0,1},
	{1,0,0,0,0,0,1,0,0,1,0,0,1},
	{1,0,1,0,1,0,1,0,0,0,0,0,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1}
};